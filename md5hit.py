import telebot
import random
import string
import json
import time
from datetime import datetime, timedelta
import re
import os # Import os ƒë·ªÉ x·ª≠ l√Ω bi·∫øn m√¥i tr∆∞·ªùng cho Flask

# Th∆∞ vi·ªán ƒë·ªÉ keep_alive (Flask)
from threading import Thread
from flask import Flask

# --- C·∫•u h√¨nh Bot ---
BOT_TOKEN = "7942509227:AAGECLHLuuvPlul1jAidqmbjIgO_9zD2AV8"  # THAY TH·∫æ B·∫∞NG TOKEN TH·∫¨T C·ª¶A B·∫†N
ADMIN_IDS = [6915752059]  # Thay th·∫ø b·∫±ng ID Telegram c·ªßa b·∫°n (Admin ch√≠nh)
GROUP_LINK = "https://t.me/+cd71g9Cwx9Y1ZTM1"  # Link nh√≥m Telegram ƒë·ªÉ ng∆∞·ªùi d√πng tham gia
SUPPORT_USERNAME = "@heheviptool"  # Username h·ªó tr·ª£

bot = telebot.TeleBot(BOT_TOKEN)

# --- D·ªØ li·ªáu ng∆∞·ªùi d√πng v√† m√£ code ---
USER_DATA_FILE = "users.json"
CODES_FILE = "codes.json"
user_data = {}
codes = {
    "CODEFREE7DAY": {"type": "vip_days", "value": 7, "used_by": None}
}

def load_data(file_path, default_data={}):
    """Loads data from a JSON file."""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            if file_path == USER_DATA_FILE:
                # Convert keys from string to int for user_data IDs
                return {int(k): v for k, v in data.items()}
            return data
    except (FileNotFoundError, json.JSONDecodeError):
        print(f"Warning: {file_path} not found or corrupted. Using default data.")
        return default_data

def save_data(file_path, data):
    """Saves data to a JSON file."""
    with open(file_path, 'w') as f:
        if file_path == USER_DATA_FILE:
            # Convert keys from int to string before saving user_data IDs
            json.dump({str(k): v for k, v in data.items()}, f, indent=4)
        else:
            json.dump(data, f, indent=4)
    # print(f"Data saved to {file_path}") # Optional: for debugging

def get_user_info(user_id):
    """Retrieves or initializes user data."""
    if user_id not in user_data:
        user_data[user_id] = {
            "name": "",
            "is_vip": False,
            "vip_expiry": None,
            "invite_count": 0,
            "invited_users": [], # To track who this user invited (list of user_ids)
            "correct_predictions": 0,
            "wrong_predictions": 0,
            "is_admin_ctv": False,
            "waiting_for_md5": False,
            "invite_link_generated": False,
            "has_claimed_free_vip": False,
            "history": []
        }
        save_data(USER_DATA_FILE, user_data)
    return user_data[user_id]

# --- VIP Status Checkers ---
def is_vip(user_id):
    """Checks if a user has active VIP status."""
    user_info = get_user_info(user_id)
    if user_info["is_vip"] and user_info["vip_expiry"]:
        try:
            expiry_time = datetime.fromisoformat(user_info["vip_expiry"])
            return datetime.now() < expiry_time
        except ValueError:
            return False
    return False

def get_vip_status_text(user_id):
    """Returns formatted VIP status string."""
    user_info = get_user_info(user_id)
    if is_vip(user_id):
        expiry_time = datetime.fromisoformat(user_info["vip_expiry"])
        return f"‚úÖ ƒê√£ k√≠ch ho·∫°t\nüóìÔ∏è H·∫øt h·∫°n: {expiry_time.strftime('%Y-%m-%d %H:%M:%S')}"
    return "‚ùå Ch∆∞a k√≠ch ho·∫°t"

# --- Admin/CTV Checkers ---
def is_admin_ctv(user_id):
    """Checks if a user is an Admin or CTV."""
    return user_id in ADMIN_IDS or get_user_info(user_id)["is_admin_ctv"]

def is_super_admin(user_id):
    """Checks if a user is a Super Admin (main admin)."""
    return user_id in ADMIN_IDS

# --- Group Membership Check (Requires bot to be Admin in the group) ---
def is_member_of_group(user_id, chat_id_group):
    """Checks if a user is a member of a specific Telegram group."""
    try:
        member = bot.get_chat_member(chat_id_group, user_id)
        return member.status in ["creator", "administrator", "member"]
    except Exception as e:
        print(f"Error checking group membership for {user_id}: {e}")
        return False

# --- VIP Activation ---
def activate_vip(user_id, days):
    """Activates or extends VIP status for a user."""
    user_info = get_user_info(user_id)
    current_expiry = None
    if user_info["is_vip"] and user_info["vip_expiry"]:
        try:
            current_expiry = datetime.fromisoformat(user_info["vip_expiry"])
        except ValueError:
            current_expiry = datetime.now()

    if current_expiry and current_expiry > datetime.now():
        new_expiry = current_expiry + timedelta(days=days)
    else:
        new_expiry = datetime.now() + timedelta(days=days)

    user_info["is_vip"] = True
    user_info["vip_expiry"] = new_expiry.isoformat()
    save_data(USER_DATA_FILE, user_data)
    return new_expiry

# --- Code Generation ---
def generate_code(length=10):
    """Generates a random alphanumeric code."""
    characters = string.ascii_uppercase + string.digits
    return ''.join(random.choice(characters) for i in range(length))

# --- Prediction Algorithm (Simulated for MD5) ---
def custom_md5_analyzer(md5_hash):
    """
    Simulated MD5 analysis function.
    This is illustrative and does not represent a real prediction algorithm.
    It incorporates the "2 G√£y : 1 kh√°c" ratio for the actual result.
    """
    try:
        # A simple "deterministic" part for Hyper-AI based on MD5 content
        # This is for demonstration of "algorithm" only.
        decimal_val = int(md5_hash[-4:], 16) # Convert last 4 hex chars to decimal
        
        # Hyper-AI (highest simulated accuracy)
        if decimal_val % 2 == 0:
            hyper_ai_pred = "X·ªàU"
            hyper_ai_prob = round(random.uniform(88, 98), 1) # High probability
        else:
            hyper_ai_pred = "T√ÄI"
            hyper_ai_prob = round(random.uniform(88, 98), 1)

        # Diamond AI (medium simulated accuracy)
        diamond_ai_pred = "X·ªàU" if random.random() < 0.55 else "T√ÄI"
        diamond_ai_prob = round(random.uniform(50, 75), 1)

        # AI-Tech Titans (good simulated accuracy)
        ai_tech_pred = "X·ªàU" if random.random() < 0.65 else "T√ÄI"
        ai_tech_prob = round(random.uniform(60, 85), 1)

        # Simulate total HEX value
        total_hex = sum(int(c, 16) for c in md5_hash)

        # Simulated algorithm statistics (e.g., success rate or "power")
        hyper_ai_stats = round(random.uniform(20.0, 30.0), 2)
        diamond_ai_stats = round(random.uniform(4.0, 10.0), 2)
        ai_tech_stats = round(random.uniform(7.0, 15.0), 2)

        # Final prediction logic (prioritize Hyper-AI if very confident)
        final_pred = hyper_ai_pred
        final_prob = hyper_ai_prob

        # If Hyper-AI is not extremely confident, combine probabilities (simplified)
        if hyper_ai_prob < 90:
            # Weighted average or majority vote
            preds_scores = {"X·ªàU": 0, "T√ÄI": 0}
            preds_scores["X·ªàU"] += hyper_ai_prob if hyper_ai_pred == "X·ªàU" else 0
            preds_scores["T√ÄI"] += hyper_ai_prob if hyper_ai_pred == "T√ÄI" else 0
            
            preds_scores["X·ªàU"] += diamond_ai_prob if diamond_ai_pred == "X·ªàU" else 0
            preds_scores["T√ÄI"] += diamond_ai_prob if diamond_ai_pred == "T√ÄI" else 0
            
            preds_scores["X·ªàU"] += ai_tech_prob if ai_tech_pred == "X·ªàU" else 0
            preds_scores["T√ÄI"] += ai_tech_prob if ai_tech_pred == "T√ÄI" else 0
            
            if preds_scores["X·ªàU"] >= preds_scores["T√ÄI"]:
                final_pred = "X·ªàU"
            else:
                final_pred = "T√ÄI"
            
            # Recalculate final probability based on the chosen prediction
            if final_pred == "X·ªàU":
                final_prob = round((hyper_ai_prob if hyper_ai_pred == "X·ªàU" else 0) * 0.5 + \
                                   (diamond_ai_prob if diamond_ai_pred == "X·ªàU" else 0) * 0.2 + \
                                   (ai_tech_prob if ai_tech_pred == "X·ªàU" else 0) * 0.3, 1)
            else:
                 final_prob = round((hyper_ai_prob if hyper_ai_pred == "T√ÄI" else 0) * 0.5 + \
                                   (diamond_ai_prob if diamond_ai_pred == "T√ÄI" else 0) * 0.2 + \
                                   (ai_tech_prob if ai_tech_pred == "T√ÄI" else 0) * 0.3, 1)
            final_prob = max(50.0, final_prob) # Ensure minimum probability
        
        risk = "TH·∫§P" if final_prob >= 80 else "TRUNG B√åNH" if final_prob >= 60 else "CAO"

        # --- Simulate actual MD5 result based on "2 G√£y : 1 Kh√°c" rule ---
        # This is a very simplistic way to enforce the rule. For a production system,
        # you'd need to persist this count in a database for consistency.
        if not hasattr(custom_md5_analyzer, "g√£y_streak"):
            custom_md5_analyzer.g√£y_streak = 0
            
        if custom_md5_analyzer.g√£y_streak < 2:
            result_md5 = "G√£y" # Simulate X·ªàU
            custom_md5_analyzer.g√£y_streak += 1
        else:
            result_md5 = random.choice(["ƒÇn", "Ho√†"]) # Simulate T√ÄI or Ho√†
            custom_md5_analyzer.g√£y_streak = 0 # Reset streak
            
        # Determine if the prediction was "correct" based on simulated actual result
        is_correct = False
        if (final_pred == "X·ªàU" and result_md5 == "G√£y") or \
           (final_pred == "T√ÄI" and result_md5 == "ƒÇn"):
            is_correct = True
        # If result_md5 is "Ho√†", it's neither correct nor wrong in this simplified model.

        # New UI for MD5 analysis result
        response_text = f"""
‚ú® **PH√ÇN T√çCH MD5 ƒê·ªòC QUY·ªÄN** ‚ú®
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîë M√£ MD5: `{md5_hash[:8]}...{md5_hash[-8:]}`
üìä T·ªïng gi√° tr·ªã HEX: **{total_hex}**
‚è∞ Th·ªùi gian: {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîÆ **D·ª± ƒëo√°n t·ª´ c√°c AI cao c·∫•p**
    üåå **HYPER-AI:** D·ª± ƒëo√°n **{hyper_ai_pred}** | ƒê·ªô tin c·∫≠y: **{hyper_ai_prob}%**
    üíé **DIAMOND AI:** D·ª± ƒëo√°n **{diamond_ai_pred}** | ƒê·ªô tin c·∫≠y: **{diamond_ai_prob}%**
    ü¶† **AI-TECH TITANS:** D·ª± ƒëo√°n **{ai_tech_pred}** | ƒê·ªô tin c·∫≠y: **{ai_tech_prob}%**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üìà **Th·ªëng k√™ hi·ªáu su·∫•t AI (S·ªë li·ªáu gi·∫£ l·∫≠p)**
    Hyper-AI: **{hyper_ai_stats}X**
    Diamond AI: **{diamond_ai_stats}X**
    AI-Tech: **{ai_tech_stats}X**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéØ **K·∫æT LU·∫¨N CU·ªêI C√ôNG**
    D·ª± ƒëo√°n: **{final_pred}**
    X√°c su·∫•t: **{final_prob}%**
    M·ª©c ƒë·ªô r·ªßi ro: **{risk}**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üö® K·∫øt qu·∫£ th·ª±c t·∫ø MD5: **{result_md5}**
    _L∆∞u √Ω: K·∫øt qu·∫£ n√†y ch·ªâ mang t√≠nh tham kh·∫£o. Ch√∫c may m·∫Øn!_
"""
        return final_pred, result_md5, is_correct, response_text

    except Exception as e:
        print(f"Error in MD5 analysis: {e}")
        return None, None, False, f"ƒê√£ x·∫£y ra l·ªói khi ph√¢n t√≠ch MD5: {e}"

# --- Decorators for access control ---
def vip_required(func):
    """Decorator to restrict access to VIP users, but allows Super Admins."""
    def wrapper(message):
        user_id = message.from_user.id
        if is_super_admin(user_id): # K√≠ch ho·∫°t t√≠nh nƒÉng cho Admin ch√≠nh
            func(message)
            return
        if not is_vip(user_id):
            bot.reply_to(message, "‚ö†Ô∏è **B·∫°n c·∫ßn c√≥ t√†i kho·∫£n VIP ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.**\nVui l√≤ng k√≠ch ho·∫°t VIP b·∫±ng c√°ch nh·∫≠p m√£ ho·∫∑c tham gia nh√≥m ƒë·ªÉ nh·∫≠n VIP mi·ªÖn ph√≠.\n\nS·ª≠ d·ª•ng /help ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.", parse_mode='Markdown')
            return
        func(message)
    return wrapper

def admin_ctv_required(func):
    """Decorator to restrict access to Admin/CTV users, but allows Super Admins."""
    def wrapper(message):
        user_id = message.from_user.id
        if is_super_admin(user_id): # K√≠ch ho·∫°t t√≠nh nƒÉng cho Admin ch√≠nh
            func(message)
            return
        if not is_admin_ctv(user_id):
            bot.reply_to(message, "‚õîÔ∏è **B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.**", parse_mode='Markdown')
            return
        func(message)
    return wrapper

def super_admin_required(func):
    """Decorator to restrict access to Super Admin users."""
    def wrapper(message):
        user_id = message.from_user.id
        if not is_super_admin(user_id):
            bot.reply_to(message, "üëë **L·ªánh n√†y ch·ªâ d√†nh cho Admin Ch√≠nh.**", parse_mode='Markdown')
            return
        func(message)
    return wrapper

# --- Bot Commands ---

@bot.message_handler(commands=['start'])
def send_welcome(message):
    """Handles the /start command."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    user_info["name"] = message.from_user.first_name or "B·∫°n"
    save_data(USER_DATA_FILE, user_data)

    # Process invite link parameter
    if message.text and len(message.text.split()) > 1:
        inviter_id_str = message.text.split()[1]
        try:
            inviter_id = int(inviter_id_str)
            # Check if inviter is valid and not self-invitation
            if inviter_id != user_id and inviter_id in user_data:
                inviter_info = get_user_info(inviter_id)
                if user_id not in inviter_info.get("invited_users", []): # Prevent multiple credits for same invited user
                    inviter_info["invite_count"] += 1
                    inviter_info["invited_users"].append(user_id) # Add invited user to inviter's list
                    
                    activate_vip(inviter_id, 1) # Credit 1 VIP day to inviter
                    bot.send_message(inviter_id, f"üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **1 ng√†y VIP** t·ª´ l∆∞·ª£t m·ªùi th√†nh c√¥ng c·ªßa ng∆∞·ªùi d√πng {user_info['name']} (ID: `{user_id}`).", parse_mode='Markdown')
                    save_data(USER_DATA_FILE, user_data)
        except ValueError:
            pass

    welcome_message = f"""
üëã Ch√†o m·ª´ng b·∫°n, **{user_info['name']}**!
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ÑπÔ∏è Tham gia nh√≥m Telegram c·ªßa ch√∫ng t√¥i ƒë·ªÉ nh·∫≠n ngay **VIP 7 ng√†y mi·ªÖn ph√≠**!

üëâ **Nh√≥m ch√≠nh th·ª©c:** {GROUP_LINK}

‚ú® Sau khi tham gia, nh·∫•n n√∫t "X√°c nh·∫≠n" ƒë·ªÉ k√≠ch ho·∫°t ∆∞u ƒë√£i VIP c·ªßa b·∫°n.
"""
    markup = telebot.types.InlineKeyboardMarkup()
    confirm_button = telebot.types.InlineKeyboardButton("‚úÖ T√¥i ƒë√£ tham gia nh√≥m", callback_data="confirm_group_join")
    markup.add(confirm_button)
    bot.send_message(user_id, welcome_message, reply_markup=markup, parse_mode='Markdown')

@bot.callback_query_handler(func=lambda call: call.data == "confirm_group_join")
def confirm_group_join_callback(call):
    """Handles callback from the 'confirm group join' button."""
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    bot.answer_callback_query(call.id, "ƒêang ki·ªÉm tra th√†nh vi√™n nh√≥m...", show_alert=False)

    # !!! REPLACE WITH YOUR ACTUAL GROUP CHAT ID (starts with -100) !!!
    group_chat_id = -1002075726245 # EXAMPLE ID: You MUST change this!
    is_member = is_member_of_group(user_id, group_chat_id)

    if is_member:
        if not user_info.get("has_claimed_free_vip"):
            expiry = activate_vip(user_id, 7)
            user_info["has_claimed_free_vip"] = True
            save_data(USER_DATA_FILE, user_data)
            bot.send_message(user_id, f"üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ tham gia nh√≥m th√†nh c√¥ng.\n\n**VIP 7 ng√†y mi·ªÖn ph√≠** c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!\nüóìÔ∏è Th·ªùi gian h·∫øt h·∫°n: {expiry.strftime('%Y-%m-%d %H:%M:%S')}", parse_mode='Markdown')
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=call.message.text + "\n\n‚úÖ **B·∫°n ƒë√£ nh·∫≠n VIP 7 ng√†y mi·ªÖn ph√≠.**", parse_mode='Markdown')
        else:
            bot.send_message(user_id, "‚ÑπÔ∏è B·∫°n ƒë√£ nh·∫≠n VIP mi·ªÖn ph√≠ 7 ng√†y tr∆∞·ªõc ƒë√≥ r·ªìi.")
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=call.message.text + "\n\nB·∫°n ƒë√£ nh·∫≠n VIP mi·ªÖn ph√≠ r·ªìi.", parse_mode='Markdown')
    else:
        bot.send_message(user_id, f"‚ùå **B·∫°n ch∆∞a tham gia nh√≥m.** Vui l√≤ng tham gia nh√≥m: {GROUP_LINK} tr∆∞·ªõc khi nh·∫•n x√°c nh·∫≠n.", parse_mode='Markdown')

@bot.message_handler(commands=['help'])
def send_help(message):
    """Sends the list of available commands and instructions."""
    help_text = f"""
üìö **C√ÅC L·ªÜNH H·ªñ TR·ª¢** üìö
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîç `/start` - B·∫Øt ƒë·∫ßu v√† nh·∫≠n th√¥ng tin ch√†o m·ª´ng.
üíé `/code [m√£]` - K√≠ch ho·∫°t m√£ VIP. Admin c√≥ th·ªÉ t·∫°o m√£ m·ªõi.
üìä `/stats` - Xem th·ªëng k√™ d·ª± ƒëo√°n c√° nh√¢n.
üìú `/history` - Xem l·ªãch s·ª≠ c√°c l·∫ßn d·ª± ƒëo√°n c·ªßa b·∫°n.
üì© `/invite` - L·∫•y link m·ªùi b·∫°n b√® nh·∫≠n VIP v√† nh·∫≠n th√™m ng√†y VIP.
üë§ `/id` - Xem th√¥ng tin t√†i kho·∫£n c·ªßa b·∫°n.
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
**ƒê·ªÉ ph√¢n t√≠ch MD5:**
    Ch·ªâ c·∫ßn g·ª≠i m√£ **MD5 (32 k√Ω t·ª±)** tr·ª±c ti·∫øp v√†o bot.
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üÜò H·ªó tr·ª£: {SUPPORT_USERNAME}
"""
    bot.send_message(message.chat.id, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['gia'])
def send_price_list(message):
    """Sends the price list for VIP services."""
    price_text = """
üí∞ **B·∫¢NG GI√Å D·ªäCH V·ª§ VIP** üí∞
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ú® **G√≥i C∆° B·∫£n (7 Ng√†y):** Mi·ªÖn ph√≠ (tham gia nh√≥m Telegram)
‚ú® **G√≥i Th∆∞·ªùng (30 Ng√†y):** 50.000 VNƒê
‚ú® **G√≥i Cao C·∫•p (Tr·ªçn ƒê·ªùi):** 200.000 VNƒê
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üí≥ ƒê·ªÉ mua VIP, vui l√≤ng li√™n h·ªá Admin/CTV ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªõng d·∫´n chi ti·∫øt.
"""
    bot.send_message(message.chat.id, price_text, parse_mode='Markdown')

@bot.message_handler(commands=['gopy'])
def receive_feedback(message):
    """Allows users to send feedback to admins."""
    feedback = message.text.replace("/gopy", "").strip()
    if not feedback:
        bot.reply_to(message, "‚úçÔ∏è Vui l√≤ng nh·∫≠p n·ªôi dung g√≥p √Ω c·ªßa b·∫°n sau l·ªánh /gopy.\nV√≠ d·ª•: `/gopy Bot ho·∫°t ƒë·ªông r·∫•t t·ªët!`", parse_mode='Markdown')
        return

    for admin_id in ADMIN_IDS:
        try:
            bot.send_message(admin_id, f"üìù **G√ìP √ù M·ªöI** t·ª´ ng∆∞·ªùi d√πng ID: `{message.from_user.id}` (T√™n: `{message.from_user.first_name or 'N/A'}`)\n\nN·ªôi dung:\n__{feedback}__", parse_mode='Markdown')
        except Exception as e:
            print(f"Kh√¥ng th·ªÉ g·ª≠i g√≥p √Ω ƒë·∫øn Admin {admin_id}: {e}")
    bot.reply_to(message, "‚úÖ **C·∫£m ∆°n b·∫°n ƒë√£ g·ª≠i g√≥p √Ω!** Ch√∫ng t√¥i s·∫Ω xem x√©t v√† ph·∫£n h·ªìi s·ªõm nh·∫•t c√≥ th·ªÉ.")

@bot.message_handler(commands=['nap'])
def top_up_guide(message):
    """Provides instructions on how to top up."""
    bot.send_message(message.chat.id, "üí≥ **H∆Ø·ªöNG D·∫™N N·∫†P TI·ªÄN** üí≥\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nƒê·ªÉ n·∫°p ti·ªÅn ho·∫∑c mua c√°c g√≥i VIP, vui l√≤ng li√™n h·ªá tr·ª±c ti·∫øp v·ªõi ƒë·ªôi ng≈© Admin ho·∫∑c CTV c·ªßa ch√∫ng t√¥i ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ v√† h∆∞·ªõng d·∫´n c·ª• th·ªÉ.\n\nüÜò Li√™n h·ªá h·ªó tr·ª£: {SUPPORT_USERNAME}", parse_mode='Markdown')

@bot.message_handler(commands=['taixiu'])
@vip_required
def get_latest_taixiu_prediction(message):
    """Prompts user to send MD5 for prediction."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    user_info["waiting_for_md5"] = True
    save_data(USER_DATA_FILE, user_data)
    bot.reply_to(message, "üìù **Vui l√≤ng g·ª≠i m√£ MD5 (32 k√Ω t·ª±)** ƒë·ªÉ t√¥i ti·∫øn h√†nh ph√¢n t√≠ch v√† ƒë∆∞a ra d·ª± ƒëo√°n.", parse_mode='Markdown')

@bot.message_handler(commands=['tat'])
def stop_notifications(message):
    """Placeholder for stopping continuous predictions (not implemented yet)."""
    bot.reply_to(message, "‚ÑπÔ∏è Ch·ª©c nƒÉng nh·∫≠n th√¥ng b√°o li√™n t·ª•c hi·ªán ch∆∞a ƒë∆∞·ª£c h·ªó tr·ª£. B·∫°n c√≥ th·ªÉ g·ª≠i m√£ MD5 b·∫•t c·ª© l√∫c n√†o ƒë·ªÉ nh·∫≠n d·ª± ƒëo√°n.")

@bot.message_handler(commands=['full'])
@admin_ctv_required
def view_user_details(message):
    """Allows Admin/CTV to view detailed user information."""
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng c·∫ßn xem. V√≠ d·ª•: `/full 123456789`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        if target_user_id not in user_data:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID n√†y.")
            return

        target_user_info = get_user_info(target_user_id)
        vip_status = get_vip_status_text(target_user_id)

        total_predictions = target_user_info['correct_predictions'] + target_user_info['wrong_predictions']
        accuracy = 0.00
        if total_predictions > 0:
            accuracy = (target_user_info['correct_predictions'] / total_predictions) * 100

        response = f"""
üë§ **TH√îNG TIN CHI TI·∫æT NG∆Ø·ªúI D√ôNG** üë§
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üÜî ID: `{target_user_id}`
‚ú® T√™n: `{target_user_info.get('name', 'N/A')}`
üåü VIP: {vip_status}
üíå L∆∞·ª£t m·ªùi: {target_user_info['invite_count']}
‚úîÔ∏è ƒê√∫ng: {target_user_info['correct_predictions']}
‚ùå Sai: {target_user_info['wrong_predictions']}
üìä Ch√≠nh x√°c: {accuracy:.2f}%
üë®‚Äçüíª CTV: {'‚úÖ C√≥' if target_user_info['is_admin_ctv'] else '‚ùå Kh√¥ng'}
"""
        bot.reply_to(message, response, parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['giahan'])
@admin_ctv_required
def extend_vip(message):
    """Allows Admin/CTV to extend a user's VIP status."""
    args = message.text.split()
    if len(args) < 3:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng v√† s·ªë ng√†y gia h·∫°n.\nV√≠ d·ª•: `/giahan 123456789 30`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        days_to_add = int(args[2])

        if target_user_id not in user_data:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID n√†y.")
            return

        if days_to_add <= 0:
            bot.reply_to(message, "S·ªë ng√†y gia h·∫°n ph·∫£i l·ªõn h∆°n 0.")
            return

        new_expiry = activate_vip(target_user_id, days_to_add)
        bot.send_message(target_user_id, f"üéâ **T√†i kho·∫£n VIP c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m {days_to_add} ng√†y b·ªüi Admin/CTV!**\nüóìÔ∏è Th·ªùi gian h·∫øt h·∫°n m·ªõi: {new_expiry.strftime('%Y-%m-%d %H:%M:%S')}", parse_mode='Markdown')
        bot.reply_to(message, f"‚úÖ ƒê√£ gia h·∫°n VIP th√†nh c√¥ng cho ng∆∞·ªùi d√πng `{target_user_id}` th√™m {days_to_add} ng√†y.", parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng ho·∫∑c s·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['ctv'])
@super_admin_required
def add_ctv(message):
    """Allows Super Admin to add a CTV."""
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng ƒë·ªÉ th√™m l√†m CTV. V√≠ d·ª•: `/ctv 123456789`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        user_info = get_user_info(target_user_id)
        user_info["is_admin_ctv"] = True
        save_data(USER_DATA_FILE, user_data)
        bot.send_message(target_user_id, "üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn CTV!")
        bot.reply_to(message, f"‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng `{target_user_id}` l√†m CTV.", parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['xoactv'])
@super_admin_required
def remove_ctv(message):
    """Allows Super Admin to remove a CTV."""
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng ƒë·ªÉ x√≥a CTV. V√≠ d·ª•: `/xoactv 123456789`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        user_info = get_user_info(target_user_id)
        user_info["is_admin_ctv"] = False
        save_data(USER_DATA_FILE, user_data)
        bot.send_message(target_user_id, "üö® **Th√¥ng b√°o:** Quy·ªÅn CTV c·ªßa b·∫°n ƒë√£ b·ªã g·ª° b·ªè.")
        bot.reply_to(message, f"‚úÖ ƒê√£ x√≥a quy·ªÅn CTV c·ªßa ng∆∞·ªùi d√πng `{target_user_id}`.", parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['tb'])
@super_admin_required
def send_broadcast(message):
    """Allows Super Admin to send a broadcast message to all users."""
    broadcast_text = message.text.replace("/tb", "").strip()
    if not broadcast_text:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o sau l·ªánh /tb.\nV√≠ d·ª•: `/tb Bot s·∫Ω b·∫£o tr√¨ v√†o 2h s√°ng.`", parse_mode='Markdown')
        return

    sent_count = 0
    all_user_ids = list(user_data.keys()) # Get all user IDs

    bot.reply_to(message, f"ƒêang g·ª≠i th√¥ng b√°o t·ªõi {len(all_user_ids)} ng∆∞·ªùi d√πng. Vui l√≤ng ch·ªù...", parse_mode='Markdown')

    for user_id in all_user_ids:
        try:
            bot.send_message(user_id, f"üì£ **TH√îNG B√ÅO T·ª™ ADMIN:**\n\n{broadcast_text}", parse_mode='Markdown')
            sent_count += 1
            time.sleep(0.1) # Small delay to avoid rate limits
        except Exception as e:
            print(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o ƒë·∫øn ng∆∞·ªùi d√πng {user_id}: {e}")
    bot.reply_to(message, f"‚úÖ ƒê√£ g·ª≠i th√¥ng b√°o t·ªõi **{sent_count}** ng∆∞·ªùi d√πng.", parse_mode='Markdown')

@bot.message_handler(commands=['code'])
def handle_code(message):
    """Handles VIP code activation for users and code generation/check for admins."""
    user_id = message.from_user.id
    args = message.text.split()

    if is_super_admin(user_id):
        if len(args) == 1: # Admin /code -> Generate new code (default 15 days)
            new_code = generate_code()
            codes[new_code] = {"type": "admin_generated", "value": 15, "used_by": None}
            save_data(CODES_FILE, codes)
            bot.reply_to(message, f"‚úÖ ƒê√£ t·∫°o m√£ VIP m·ªõi: `{new_code}` (15 ng√†y VIP).\n\n_L∆∞u √Ω: B·∫°n c√≥ th·ªÉ ch·ªânh s·ª≠a s·ªë ng√†y trong codes.json n·∫øu c·∫ßn._", parse_mode='Markdown')
        elif len(args) == 2:
            arg_value = args[1].upper()
            try:
                days_to_add = int(arg_value) # Try to interpret as number of days
                if days_to_add <= 0:
                    bot.reply_to(message, "‚ùå S·ªë ng√†y ph·∫£i l√† s·ªë nguy√™n d∆∞∆°ng.", parse_mode='Markdown')
                    return
                new_code = generate_code()
                codes[new_code] = {"type": "admin_generated", "value": days_to_add, "used_by": None}
                save_data(CODES_FILE, codes)
                bot.reply_to(message, f"‚úÖ ƒê√£ t·∫°o m√£ VIP m·ªõi: `{new_code}` (VIP {days_to_add} ng√†y).", parse_mode='Markdown')
            except ValueError: # Not a number, assume it's a code to check
                code_to_check = arg_value
                if code_to_check in codes:
                    code_info = codes[code_to_check]
                    status = "Ch∆∞a s·ª≠ d·ª•ng" if code_info["used_by"] is None else f"ƒê√£ s·ª≠ d·ª•ng b·ªüi `{code_info['used_by']}`"
                    bot.reply_to(message, f"""
üîë **TH√îNG TIN M√É VIP** üîë
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
M√£: `{code_to_check}`
Lo·∫°i: `{code_info['type']}`
Gi√° tr·ªã: `{code_info['value']}` ng√†y
Tr·∫°ng th√°i: `{status}`
""", parse_mode='Markdown')
                else:
                    bot.reply_to(message, "‚ùå M√£ n√†y kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng.", parse_mode='Markdown')
        else:
            bot.reply_to(message, "üìù L·ªánh `/code` d√†nh cho Admin:\n- `/code`: T·∫°o m√£ VIP m·ªõi (15 ng√†y).\n- `/code [s·ªë_ng√†y]`: T·∫°o m√£ VIP v·ªõi s·ªë ng√†y c·ª• th·ªÉ.\n- `/code [m√£]`: Ki·ªÉm tra th√¥ng tin m√£ VIP c·ª• th·ªÉ.", parse_mode='Markdown')
        return

    # User uses /code [m√£]
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p m√£ k√≠ch ho·∫°t VIP sau l·ªánh /code.\nV√≠ d·ª•: `/code CODEFREE7DAY`", parse_mode='Markdown')
        return

    user_code = args[1].upper()
    if user_code not in codes:
        bot.reply_to(message, "‚ùå M√£ k√≠ch ho·∫°t kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.", parse_mode='Markdown')
        return

    code_info = codes[user_code]
    if code_info["used_by"] is not None:
        bot.reply_to(message, "‚ö†Ô∏è M√£ n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ng∆∞·ªùi kh√°c r·ªìi.", parse_mode='Markdown')
        return
    
    # Special check for CODEFREE7DAY: one-time use per user
    if user_code == "CODEFREE7DAY":
        user_info = get_user_info(user_id)
        if user_info.get("has_claimed_free_vip"):
            bot.reply_to(message, "‚ùå M√£ `CODEFREE7DAY` ch·ªâ c√≥ th·ªÉ s·ª≠ d·ª•ng **m·ªôt l·∫ßn duy nh·∫•t** cho m·ªói t√†i kho·∫£n.", parse_mode='Markdown')
            return
        user_info["has_claimed_free_vip"] = True # Mark as claimed
        save_data(USER_DATA_FILE, user_data)

    # Activate VIP for the user
    days = code_info["value"]
    expiry = activate_vip(user_id, days)
    code_info["used_by"] = user_id # Mark code as used
    save_data(CODES_FILE, codes)

    bot.reply_to(message, f"üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ k√≠ch ho·∫°t VIP th√†nh c√¥ng v·ªõi m√£ `{user_code}`.\n\nTh·ªùi gian VIP c·ªßa b·∫°n k√©o d√†i th√™m **{days} ng√†y** v√† s·∫Ω h·∫øt h·∫°n v√†o: {expiry.strftime('%Y-%m-%d %H:%M:%S')}", parse_mode='Markdown')

@bot.message_handler(commands=['stats'])
def show_stats(message):
    """Displays user's prediction statistics."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)

    total_predictions = user_info['correct_predictions'] + user_info['wrong_predictions']
    accuracy = 0.00
    if total_predictions > 0:
        accuracy = (user_info['correct_predictions'] / total_predictions) * 100

    stats_message = f"""
üìà **TH·ªêNG K√ä D·ª∞ ƒêO√ÅN C√Å NH√ÇN** üìà
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úîÔ∏è S·ªë l·∫ßn d·ª± ƒëo√°n ƒë√∫ng: **{user_info['correct_predictions']}**
‚ùå S·ªë l·∫ßn d·ª± ƒëo√°n sai: **{user_info['wrong_predictions']}**
üìä T·ª∑ l·ªá ch√≠nh x√°c: **{accuracy:.2f}%**
"""
    bot.send_message(user_id, stats_message, parse_mode='Markdown')

@bot.message_handler(commands=['history'])
@vip_required # Requires VIP to view detailed history (Admin bypasses this)
def show_history(message):
    """Displays a user's recent prediction history."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)

    history_text = "üìú **L·ªäCH S·ª¨ D·ª∞ ƒêO√ÅN C·ª¶A B·∫†N** üìú\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    if not user_info['history']:
        history_text += "B·∫°n ch∆∞a c√≥ l·ªãch s·ª≠ d·ª± ƒëo√°n n√†o."
    else:
        # Display up to 10 most recent entries
        for entry in user_info['history'][-10:]:
            status = "‚úÖ ƒê√öNG" if entry['is_correct'] else "‚ùå SAI"
            history_text += f"- MD5: `{entry['md5_short']}` | D·ª± ƒëo√°n: **{entry['prediction']}** | K·∫øt qu·∫£: **{entry['result_md5']}** | Status: **{status}** | L√∫c: {entry['time']}\n"
        
        if len(user_info['history']) > 10:
            history_text += "\n_... v√† nhi·ªÅu h∆°n n·ªØa. Ch·ªâ hi·ªÉn th·ªã 10 m·ª•c g·∫ßn nh·∫•t._"

    bot.send_message(user_id, history_text, parse_mode='Markdown')

@bot.message_handler(commands=['invite', 'moiban'])
def send_invite_link(message):
    """Generates and sends a unique invite link for the user."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    bot_username = bot.get_me().username # Get bot's username dynamically
    invite_link = f"https://t.me/{bot_username}?start={user_id}"

    user_info["invite_link_generated"] = True
    save_data(USER_DATA_FILE, user_data)

    invite_message = f"""
üíå **M·ªúI B·∫†N B√à, NH·∫¨N VIP MI·ªÑN PH√ç!** üíå
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üì¢ Chia s·∫ª link n√†y ƒë·ªÉ m·ªùi b·∫°n b√® tham gia bot:
üîó **Link m·ªùi c·ªßa b·∫°n:** `{invite_link}`

üéÅ C·ª© m·ªói 1 ng∆∞·ªùi b·∫°n m·ªùi th√†nh c√¥ng (tham gia bot v√† ƒë∆∞·ª£c bot ghi nh·∫≠n), b·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c **1 ng√†y VIP mi·ªÖn ph√≠**!
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üë• T·ªïng s·ªë l∆∞·ª£t m·ªùi th√†nh c√¥ng c·ªßa b·∫°n: **{user_info['invite_count']}**
"""
    bot.send_message(user_id, invite_message, parse_mode='Markdown')

@bot.message_handler(commands=['id'])
def show_account_info(message):
    """Displays a user's account information."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)

    vip_status_text = get_vip_status_text(user_id)
    vip_status_line1 = vip_status_text.splitlines()[0]
    vip_expiry_line = vip_status_text.splitlines()[1].replace('üóìÔ∏è H·∫øt h·∫°n: ', '') if len(vip_status_text.splitlines()) > 1 else 'N/A'

    total_predictions = user_info['correct_predictions'] + user_info['wrong_predictions']
    accuracy = 0.00
    if total_predictions > 0:
        accuracy = (user_info['correct_predictions'] / total_predictions) * 100

    account_info_message = f"""
üë§ **TH√îNG TIN T√ÄI KHO·∫¢N C·ª¶A B·∫†N** üë§
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ú® T√™n: **{user_info.get('name', message.from_user.first_name)}**
üÜî ID: `{user_id}`
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üíé Tr·∫°ng th√°i VIP: **{vip_status_line1}**
‚è∞ H·∫øt h·∫°n: **{vip_expiry_line}**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úâÔ∏è L∆∞·ª£t m·ªùi th√†nh c√¥ng: **{user_info['invite_count']}**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üìä **Th·ªëng k√™ d·ª± ƒëo√°n:**
    ‚úîÔ∏è ƒê√∫ng: **{user_info['correct_predictions']}**
    ‚ùå Sai: **{user_info['wrong_predictions']}**
    üéØ T·ª∑ l·ªá ch√≠nh x√°c: **{accuracy:.2f}%**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üÜò H·ªó tr·ª£: {SUPPORT_USERNAME}
"""
    bot.send_message(user_id, account_info_message, parse_mode='Markdown')

# --- Handles all text messages, primarily for MD5 input ---
@bot.message_handler(func=lambda message: True)
def handle_text_messages(message):
    """Handles incoming text messages, focusing on MD5 analysis."""
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    text = message.text.strip()

    # Allow Super Admin to bypass VIP requirement for MD5 analysis
    if not is_super_admin(user_id) and not is_vip(user_id):
        # If not an MD5 and not VIP, provide general instructions or VIP prompt
        if not re.fullmatch(r"[0-9a-fA-F]{32}", text):
            bot.reply_to(message, "ü§î T√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng s·ª≠ d·ª•ng c√°c l·ªánh c√≥ s·∫µn (v√≠ d·ª•: `/help`) ho·∫∑c g·ª≠i m√£ MD5 ƒë·ªÉ t√¥i ph√¢n t√≠ch.\n\n‚ö†Ô∏è **ƒê·ªÉ ph√¢n t√≠ch MD5, b·∫°n c·∫ßn c√≥ t√†i kho·∫£n VIP.** S·ª≠ d·ª•ng /help ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.", parse_mode='Markdown')
            return
        else: # If it's an MD5 but user is not VIP
            bot.reply_to(message, "‚ö†Ô∏è **B·∫°n c·∫ßn c√≥ t√†i kho·∫£n VIP ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng ph√¢n t√≠ch MD5 n√†y.**\nVui l√≤ng k√≠ch ho·∫°t VIP b·∫±ng c√°ch nh·∫≠p m√£ ho·∫∑c tham gia nh√≥m ƒë·ªÉ nh·∫≠n VIP mi·ªÖn ph√≠.\n\nS·ª≠ d·ª•ng /help ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.", parse_mode='Markdown')
            return

    # If user is VIP or Super Admin, proceed with MD5 analysis
    if user_info["waiting_for_md5"] or re.fullmatch(r"[0-9a-fA-F]{32}", text):
        if re.fullmatch(r"[0-9a-fA-F]{32}", text):
            predicted_result, result_md5, is_correct, analysis_output = custom_md5_analyzer(text)
            
            if predicted_result is not None:
                bot.reply_to(message, analysis_output, parse_mode='Markdown')

                # Update user statistics and history (tracked for both VIP users and Admin)
                if is_correct:
                    user_info["correct_predictions"] += 1
                else:
                    user_info["wrong_predictions"] += 1
                
                user_info["history"].append({
                    "md5_short": f"{text[:4]}...{text[-4:]}", # Store short form for history
                    "prediction": predicted_result,
                    "result_md5": result_md5, # Simulated actual result (e.g., G√£y/ƒÇn)
                    "is_correct": is_correct,
                    "time": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                })
                user_info["history"] = user_info["history"][-50:] # Keep last 50 entries

                save_data(USER_DATA_FILE, user_data)
            else:
                bot.reply_to(message, analysis_output) # Display error if analysis failed
            
            user_info["waiting_for_md5"] = False
            save_data(USER_DATA_FILE, user_data)
        else:
            bot.reply_to(message, "‚ùå M√£ MD5 kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ƒë√∫ng **32 k√Ω t·ª± MD5** (ch·ªâ ch·ª©a ch·ªØ s·ªë 0-9 v√† ch·ªØ c√°i a-f).", parse_mode='Markdown')
    else:
        # If not an MD5 and not waiting for MD5, provide general instructions
        bot.reply_to(message, "ü§î T√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng s·ª≠ d·ª•ng c√°c l·ªánh c√≥ s·∫µn (v√≠ d·ª•: `/help`) ho·∫∑c g·ª≠i m√£ MD5 ƒë·ªÉ t√¥i ph√¢n t√≠ch.", parse_mode='Markdown')


# --- Keep alive server for Render/UptimeRobot ---
app = Flask(__name__)

@app.route('/')
def home():
    """Simple route to keep the app alive."""
    return "Bot is alive!"

def run_flask_app():
    """Runs the Flask app in a separate thread."""
    # Render will typically use the PORT environment variable.
    # If not set, or for local testing, a random port is used.
    port = int(os.environ.get('PORT', random.randint(2000, 9000)))
    print(f"Flask app running on port {port}")
    app.run(host='0.0.0.0', port=port)

# --- Bot Initialization and Start ---
if __name__ == "__main__":
    # Load data from JSON files
    user_data = load_data(USER_DATA_FILE)
    codes = load_data(CODES_FILE, default_data=codes) # Use default `codes` if file is empty or missing
    print("Bot is starting...")

    # Start the Flask app in a separate thread to keep the bot alive
    t = Thread(target=run_flask_app)
    t.start()

    # Start the Telegram bot polling
    print("Telegram bot polling started...")
    bot.polling(non_stop=True)
